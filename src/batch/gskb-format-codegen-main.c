/*
    GSKB - a batch processing framework

    gskb-format-codegen:  main program for code generation.

    Copyright (C) 2008 Dave Benson

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307  USA

    Contact:
        daveb@ffem.org <Dave Benson>
*/

#include <errno.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/stat.h>
#include "gskb-codegen-config.h"
#include "../gskutils.h"
#include "../gskinit.h"

static const char *cmdline_input = NULL;

static const char *cmdline_basename = NULL;
static gboolean cmdline_all_static = FALSE;


static const char *do_not_handedit_warning =
  "/* This file is generated by gskb-format-codegen.\n"
  " * If you edit it, your changes will probably be lost.\n"
  " */\n";

static void
write_buffers_or_die (const char *fname,
                      guint       n_buffers,
                      GskBuffer **buffers)
{
  int fd = open (fname, O_CREAT|O_TRUNC|O_WRONLY, 0666);
  guint i;
  if (fd < 0)
    g_error ("error creating %s: %s", fname, g_strerror (errno));
  for (i = 0; i < n_buffers; i++)
    {
      while (buffers[i]->size > 0)
        {
          if (gsk_buffer_writev (buffers[i], fd) < 0)
            g_error ("error writing to %s: %s",
                     fname, g_strerror (errno));
        }
    }
  close (fd);
}

static GOptionEntry op_entries[] = 
{
  { "input", 'i', 0, G_OPTION_ARG_FILENAME, &cmdline_input,
    "input file containing the formats", "FILE" },
  { "basename", 'o', 0, G_OPTION_ARG_FILENAME, &cmdline_basename,
    "output file basename", "FILE" },
  { "all-static", '\0', 0, G_OPTION_ARG_NONE, &cmdline_all_static,
    "generate all functions as static functions", NULL },
  { NULL, '\0', 0, 0, NULL, NULL, NULL }
};

int main(int argc, char **argv)
{
  GOptionContext *op_context;
  GError *error = NULL;
  GskbCodegenConfig *config;
  guint ns_index;

  gsk_init_without_threads (&argc, &argv);

  op_context = g_option_context_new (NULL);
  g_option_context_set_summary (op_context, "GSKB Code Generator");
  g_option_context_add_main_entries (op_context, op_entries, NULL);
  g_option_context_set_description (op_context,
              "Generating GSKB Formatted Data Manipulation Code");
  if (!g_option_context_parse (op_context, &argc, &argv, &error))
    gsk_fatal_user_error ("error parsing command-line options: %s",
                          error->message);
  g_option_context_free (op_context);

  if (cmdline_input == NULL)
    gsk_fatal_user_error ("--input is required");

  config = gskb_codegen_config_new ();
  if (cmdline_all_static)
    gskb_codegen_config_set_all_static (config, TRUE);

  /* parse formatted namespace */
  GskbContext *context;
  context = gskb_context_new ();
  if (!gskb_context_parse_file (context, cmdline_input, &error))
    gsk_fatal_user_error ("error parsing gskb namespace %s: %s",
                          cmdline_input, error->message);

  /* generate code */
  GskBuffer decls = GSK_BUFFER_STATIC_INIT, impls = GSK_BUFFER_STATIC_INIT;
  if (!config->all_static)
    {
      gsk_buffer_append_string (&impls, do_not_handedit_warning);
      gsk_buffer_printf (&impls, "#include \"%s.h\"\n\n",
                         cmdline_basename);
    }
  gsk_buffer_append_string (&decls, do_not_handedit_warning);
  gsk_buffer_printf (&decls, "#include \"gskb-format.h\"\n"
                             "#include \"gskb-str-table.h\"\n"
                             "#include \"gskb-uint-table.h\"\n"
                             "#include \"gskb-str-table-internals.h\"\n"
                             "#include \"gskb-uint-table-internals.h\"\n"
                             "#include \"gskb-fundamental-formats.h\"\n"
                             "#include \"../gskerror.h\"\n"
                             "#include \"gskb-config.h\"\n");

  for (ns_index = 0;
       ns_index < context->implemented_namespaces->len;
       ns_index++)
    {
      GskbNamespace *ns = context->implemented_namespaces->pdata[ns_index];
      static const GskbCodegenSection decls_section_order[] = {
        GSKB_CODEGEN_SECTION_TYPEDEFS,
        GSKB_CODEGEN_SECTION_STRUCTURES,
        GSKB_CODEGEN_SECTION_FUNCTION_PROTOTYPES,
        GSKB_CODEGEN_SECTION_FORMAT_DECLS,
        GSKB_CODEGEN_SECTION_FORMAT_PRIVATE_DECLS,
        GSKB_CODEGEN_SECTION_NAMESPACE_DECL
      };
      static const GskbCodegenSection impls_section_order[] = {
        GSKB_CODEGEN_SECTION_FORMAT_IMPLS,
        GSKB_CODEGEN_SECTION_FUNCTION_IMPLS,
        GSKB_CODEGEN_SECTION_NAMESPACE_IMPL
      };
      guint i;
      gskb_namespace_make_nonwritable (ns);
      gsk_buffer_printf (&decls,
                         "\n/*\n *\n * Namespace:   %s\n *\n */\n",
                         ns->name);
      for (i = 0; i < G_N_ELEMENTS (decls_section_order); i++)
        gskb_namespace_codegen (ns, decls_section_order[i], config, &decls);
      for (i = 0; i < G_N_ELEMENTS (impls_section_order); i++)
        gskb_namespace_codegen (ns, impls_section_order[i], config, &impls);
    }

  if (config->all_static)
    {
      char *fname = g_strdup_printf ("%s.include", cmdline_basename);
      GskBuffer *buffers[2] = { &decls, &impls };
      write_buffers_or_die (fname, 2, buffers);
      g_free (fname);
    }
  else
    {
      char *fname;
      GskBuffer *p[1];
      fname = g_strdup_printf ("%s.h", cmdline_basename);
      p[0] = &decls;
      write_buffers_or_die (fname, 1, p);
      g_free (fname);
      fname = g_strdup_printf ("%s.c", cmdline_basename);
      p[0] = &impls;
      write_buffers_or_die (fname, 1, p);
      g_free (fname);
    }
  gskb_codegen_config_free (config);

  return 0;
}
